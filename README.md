# project-parallel-processing-fainal

## ساختار کلی API

هر دو API (Process و Thread) از ساختار یکسانی پیروی می‌کنند:

1. **ورودی**: درخواست POST به endpoint `/api/run-scenario`
2. **پارامترهای ورودی**:
   - `section_type`: نوع بخش (process یا thread)
   - `section_name`: نام بخش
   - `scenario_number`: شماره سناریو (1 تا 3)
   - `parameters`: پارامترهای اختیاری

3. **خروجی**: پاسخ JSON با ساختار زیر:
   ```json
   {
     "section_type": "process",
     "section_name": "Spawning a process",
     "section_number": 1,
     "scenario_number": 1,
     "output": ["خروجی خط 1", "خروجی خط 2", ...],
     "explanation": "توضیح کامل سناریو"
   }
   ```

---

## Process-Based Parallelism API

### بخش 1: Spawning a process (ایجاد فرآیند)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: ایجاد 6 فرآیند موازی که همزمان اجرا می‌شوند
- **توضیح**: در این سناریو، 6 فرآیند به صورت موازی ایجاد و اجرا می‌شوند. هر فرآیند تابع `myFunc_s1_sc1` را اجرا می‌کند که ابتدا پیام شروع را چاپ کرده و سپس اعداد 0 تا i-1 را چاپ می‌کند. از Lock برای هماهنگی دسترسی به خروجی مشترک استفاده شده است.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: ایجاد فرآیندها به صورت سریال
- **توضیح**: در این سناریو، فرآیندها به صورت سریال ایجاد و اجرا می‌شوند. هر فرآیند بلافاصله بعد از ایجاد join می‌شود، بنابراین فرآیندها به ترتیب اجرا شده و منتظر پایان یکدیگر می‌مانند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: ایجاد فرآیندها با تاخیرهای تصادفی
- **توضیح**: در این سناریو، فرآیندها با تاخیرهای تصادفی بین 0.01 تا 0.1 ثانیه ایجاد می‌شوند. این باعث می‌شود ترتیب اجرای فرآیندها غیرقابل پیش‌بینی باشد و رفتار غیرهمزمانی را نشان دهد.

---

### بخش 2: Naming a process (نامگذاری فرآیند)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: ایجاد دو فرآیند با نام‌های مختلف
- **توضیح**: یک فرآیند با نام "myFunc process" و دیگری با نام پیش‌فرض سیستم (Process-2) ایجاد می‌شوند. تفاوت نام فرآیندها در خروجی قابل مشاهده است.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: ایجاد چندین فرآیند با نام‌های مختلف
- **توضیح**: سه فرآیند ایجاد می‌شوند که یکی نام اختصاصی و دو تای دیگر نام پیش‌فرض دارند. تاخیر 0.1 ثانیه بین شروع فرآیندها اضافه شده است.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: تغییر نام فرآیند در حین اجرا
- **توضیح**: دو فرآیند ایجاد می‌شوند که یکی از آنها (Process-2) در حین اجرا نام خود را به "Renamed-Process" تغییر می‌دهد.

---

### بخش 3: Running processes in background (اجرای فرآیندها در پس‌زمینه)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: اجرای فرآیند عادی با انتظار برای پایان
- **توضیح**: یک فرآیند عادی ایجاد شده و فرآیند اصلی منتظر پایان آن می‌ماند (با استفاده از join).

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: اجرای فرآیند پس‌زمینه بدون انتظار
- **توضیح**: دو فرآیند ایجاد می‌شوند که یکی عادی و دیگری پس‌زمینه است. فرآیند اصلی فقط برای فرآیند عادی join می‌کند و بدون انتظار برای فرآیند پس‌زمینه ادامه می‌دهد.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: اجرای فرآیند دیمون
- **توضیح**: یک فرآیند دیمون ایجاد می‌شود که با پایان فرآیند اصلی به صورت خودکار terminate می‌شود.

---

### بخش 4: Killing a process (متوقف کردن فرآیند)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: متوقف کردن فرآیند با terminate
- **توضیح**: یک فرآیند طولانی ایجاد شده و پس از 1 ثانیه با استفاده از terminate متوقف می‌شود. کد خروجی -15 (SIGTERM) نشان‌دهنده توقف graceful است.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: متوقف کردن فرآیند با kill
- **توضیح**: یک فرآیند بی‌نهایت ایجاد شده و پس از 1 ثانیه با استفاده از kill متوقف می‌شود. این معادل ارسال SIGKILL است.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: متوقف کردن graceful فرآیند
- **توضیح**: یک فرآیند که به صورت periodic کار می‌کند ایجاد شده و پس از 1.5 ثانیه متوقف می‌شود. فرآیند با بررسی exitcode متوجه توقف می‌شود و cleanup انجام می‌دهد.

---

### بخش 5: Process subclass (زیرکلاس فرآیند)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: ایجاد فرآیند با subclass پایه
- **توضیح**: 10 فرآیند با استفاده از زیرکلاس MyProcess_s5_sc1 ایجاد می‌شوند که متد run آن را override کرده است.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: ایجاد فرآیند با تاخیرهای قابل تنظیم
- **توضیح**: 10 فرآیند با تاخیرهای مختلف (0.05 تا 0.5 ثانیه) ایجاد می‌شوند. هر فرآیند پس از اتمام، پیام completion را چاپ می‌کند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: ایجاد فرآیند پیشرفته با قابلیت توقف
- **توضیح**: 10 فرآیند با مدت‌زمان کاری تصادفی ایجاد می‌شوند. پس از 0.5 ثانیه، همه فرآیندها با استفاده از متد stop متوقف می‌شوند.

---

### بخش 6: Using queue for data exchange (استفاده از صف برای تبادل داده)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: تبادل داده با Queue
- **توضیح**: یک تولیدکننده (producer) 5 آیتم تصادفی به صف اضافه می‌کند و یک مصرف‌کننده (consumer) آنها را از صف خارج می‌کند.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: الگوی Worker با Queue
- **توضیح**: سه worker ایجاد می‌شوند که tasks را از یک صف گرفته، پردازش می‌کنند (ضرب در 2) و results را در صف دیگری قرار می‌دهند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: Queue با اولویت‌بندی
- **توضیح**: یک تولیدکننده آیتم‌ها را با اولویت HIGH یا LOW در دو صف مختلف قرار می‌دهد. مصرف‌کننده ابتدا آیتم‌های HIGH priority را پردازش می‌کند.

---

### بخش 7: Synchronizing processes (همگام‌سازی فرآیندها)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: هماهنگی با Barrier
- **توضیح**: دو فرآیند با Barrier هماهنگ می‌شوند و دو فرآیند بدون Barrier. فرآیندهای با Barrier همزمان اجرا می‌شوند.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: هماهنگی با Lock
- **توضیح**: دو فرآیند با Lock به منبع مشترک دسترسی پیدا می‌کنند و دو فرآیند مستقل کار می‌کنند. دسترسی به منبع مشترک با Lock هماهنگ می‌شود.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: هماهنگی پیشرفته با Event و Semaphore
- **توضیح**: چهار فرآیند هماهنگ شده با Event و Semaphore و دو فرآیند مستقل. فرآیندهای هماهنگ شده منتظر event می‌مانند و سپس با Semaphore هماهنگ می‌شوند.

---

### بخش 8: Using process pool (استفاده از استخر فرآیند)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: استفاده از Pool برای محاسبه مربع اعداد
- **توضیح**: یک Pool با 4 فرآیند ایجاد شده و مربع اعداد 0 تا 99 به صورت موازی محاسبه می‌شود.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: استفاده از map_async برای اجرای غیرمسدود کننده
- **توضیح**: از map_async برای اجرای غیرمسدود کننده استفاده می‌شود. فرآیند اصلی می‌تواند کارهای دیگر انجام دهد while results آماده می‌شوند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: استفاده از imap برای نتایج تدریجی
- **توضیح**: از imap برای دریافت نتایج به صورت تدریجی استفاده می‌شود. هر نتیجه به محض آماده شدن در دسترس قرار می‌گیرد.

---

## Thread-Based Parallelism API

### بخش 1: Defining a thread (تعریف نخ)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: ایجاد 10 نخ به صورت موازی
- **توضیح**: 10 نخ به صورت موازی ایجاد و اجرا می‌شوند که هر کدام پیامی را چاپ می‌کنند.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: ایجاد نخ با تاخیرهای مختلف
- **توضیح**: 10 نخ با تاخیرهای مختلف (0.1 تا 1.0 ثانیه) ایجاد می‌شوند. نخ‌ها با تاخیرهای مختلف به پایان می‌رسند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: ایجاد نخ با نام‌های یونانی
- **توضیح**: 10 نخ با نام‌های یونانی (Alpha, Beta, Gamma, ...) ایجاد می‌شوند.

---

### بخش 2: Determining the current thread (تشخیص نخ جاری)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: اجرای سه تابع مختلف در نخ‌های جداگانه
- **توضیح**: سه تابع مختلف (A, B, C) در سه نخ جداگانه اجرا می‌شوند که هر کدام زمان اجرای مختلفی دارند.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: نمایش اطلاعات نخ جاری
- **توضیح**: 5 نخ ایجاد می‌شوند که اطلاعات نخ جاری شامل نام و شناسه را نمایش می‌دهند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: مقایسه رفتار نخ‌های daemon و normal
- **توضیح**: یک نخ daemon و یک نخ normal ایجاد می‌شوند. نخ daemon با پایان نخ اصلی terminate می‌شود و پیام پایانی آن چاپ نمی‌شود.

---

### بخش 3: Thread subclass (زیرکلاس نخ)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: ایجاد نخ با subclass
- **توضیح**: 9 نخ با استفاده از زیرکلاس CustomThread ایجاد می‌شوند که اطلاعات process ID را نمایش می‌دهند.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: نخ‌های شمارنده با پارامترهای مختلف
- **توضیح**: دو نخ شمارنده با پارامترهای مختلف ایجاد می‌شوند که هر کدام تا عدد متفاوتی می‌شمارند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: نخ‌های زمان‌بندی شده
- **توضیح**: چهار نخ با مدت زمان مختلف (0.5 تا 2.0 ثانیه) ایجاد می‌شوند که زمان اجرای خود را گزارش می‌کنند.

---

### بخش 4: Synchronization with Lock (همگام‌سازی با قفل)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: همگام‌سازی با Lock
- **توضیح**: 9 نخ با استفاده از Lock هماهنگ می‌شوند. هر نخ باید Lock را acquire کند قبل از چاپ خروجی.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: همگام‌سازی دسترسی به لیست مشترک
- **توضیح**: 5 نخ به یک لیست مشترک با استفاده از Lock دسترسی پیدا می‌کنند تا از شرایط مسابقه جلوگیری شود.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: نمایش رفتار Lock با تاخیرهای مختلف
- **توضیح**: 5 نخ با تاخیرهای مختلف سعی در acquire کردن Lock دارند. رفتار blocking Lock نمایش داده می‌شود.

---

### بخش 5: Synchronization with RLock (همگام‌سازی با قفل بازگشتی)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: استفاده از RLock برای عملیات همزمان
- **توضیح**: دو نخ با استفاده از RLock به منابع مشترک دسترسی پیدا می‌کنند. یکی آیتم اضافه می‌کند و دیگری آیتم حذف می‌کند.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: الگوی Producer-Consumer با RLock
- **توضیح**: یک تولیدکننده و یک مصرف‌کننده با استفاده از RLock به یک منبع مشترک دسترسی پیدا می‌کنند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: نمایش قابلیت بازگشتی RLock
- **توضیح**: یک تابع بازگشتی که چندین بار RLock را acquire و release می‌کند. قابلیت بازگشتی RLock اجازه می‌دهد同一个نخ چندین بار Lock را acquire کند.

---

### بخش 6: Synchronization with Semaphores (همگام‌سازی با سمافور)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: الگوی Producer-Consumer با Semaphore
- **توضیح**: چندین تولیدکننده و مصرف‌کننده با استفاده از Semaphore هماهنگ می‌شوند. Semaphore اندازه بافر را محدود می‌کند.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: محدود کردن تعداد اتصالات همزمان
- **توضیح**: 8 نخ سعی در برقراری ارتباط با دیتابیس دارند، اما فقط 3 connection همزمان مجاز است با استفاده از Semaphore.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: مدیریت منابع محدود با Semaphore
- **توضیح**: 10 مشتری سعی در خرید بلیط دارند، اما فقط 5 بلیط موجود است. Semaphore تعداد بلیط‌های available را مدیریت می‌کند.

---

### بخش 7: Synchronization with Barrier (همگام‌سازی با مانع)

#### سناریو 1:
- **ورودی**: `scenario_number=1`
- **خروجی**: مسابقه با Barrier برای هماهنگی شروع
- **توضیح**: سه مسابقه‌دهنده (Dewey, Huey, Louie) باید در barrier منتظر بمانند تا همه آماده شوند، سپس مسابقه همزمان شروع می‌شود.

#### سناریو 2:
- **ورودی**: `scenario_number=2`
- **خروجی**: هماهنگی فازهای کاری با Barrier
- **توضیح**: 4 worker در دو فاز کار می‌کنند. همه workerها必须 قبل از شروع فاز دوم در barrier منتظر بمانند.

#### سناریو 3:
- **ورودی**: `scenario_number=3`
- **خروجی**: هماهنگی بازیکنان تیم‌های مختلف
- **توضیح**: 6 بازیکن از 2 تیم مختلف必须 قبل از شروع بازی در barrier منتظر بمانند. بازی فقط وقتی شروع می‌شود که همه بازیکنان آماده باشند.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# توضیحات کامل صفحه وب پروژه پردازش موازی

## طراحی و پیاده‌سازی رابط کاربری

صفحه وب طراحی شده برای پروژه پردازش موازی، یک رابط کاربری intuitive و کاربرپسند ارائه می‌دهد که به کاربران امکان می‌دهد به راحتی بین سناریوهای مختلف Thread و Process جابجا شده و نتایج را مشاهده کنند.

## ساختار صفحه وب

### ۱. بخش هدر (Header)
- **عنوان پروژه**: "پروژه پردازش موازی" با آیکون CPU
- **توضیح کوتاه**: "ارائه انواع پردازش‌های موازی با Thread و Process"
- **نام دانشجو**: نمایش نام توسعه‌دهنده (مهتاب ساران)

### ۲. فرم تنظیمات پردازش
این بخش شامل سه dropdown برای انتخاب گزینه‌های مختلف است:

#### الف) انتخاب نوع پردازش:
- **Thread-Based Parallelism**: برای پردازش‌های مبتنی بر نخ
- **Process-Based Parallelism**: برای پردازش‌های مبتنی بر فرآیند

#### ب) انتخاب ابزار همزمانی:
- برای Thread: 7 گزینه (Defining a thread تا Synchronization with Barrier)
- برای Process: 8 گزینه (Spawning a process تا Using process pool)

#### ج) انتخاب شماره سناریو:
- همیشه 3 گزینه (سناریو 1، سناریو 2، سناریو 3)

### ۳. بخش نتایج
پس از اجرای سناریو، نتایج در این بخش نمایش داده می‌شود:
- اطلاعات کلی (نوع پردازش، ابزار همزمانی، شماره سناریو، زمان اجرا)
- خروجی کد در یک قالب قابل خواندن
- توضیحات کامل درباره سناریو اجرا شده

### ۴. indicator لودینگ
هنگام ارسال درخواست به سرور، یک animation لودینگ نمایش داده می‌شود.

## ویژگی‌های فنی

### ۱. طراحی واکنش‌گرا (Responsive)
- صفحه وب با استفاده از Bootstrap طراحی شده است
- در دستگاه‌های مختلف (موبایل، تبلت، دسکتاپ) به درستی نمایش داده می‌شود
- layout به صورت ریسپانسیو تغییر می‌کند

### ۲. تعامل پویا (Dynamic Interaction)
- dropdownها به صورت آبشاری عمل می‌کنند
- انتخاب نوع پردازش، گزینه‌های ابزار همزمانی را به روز می‌کند
- انتخاب ابزار همزمانی، گزینه‌های سناریو را فعال می‌کند

### ۳. ارتباط با سرور (API Integration)
- ارسال درخواست POST به endpoint `/api/run-scenario`
- ارسال پارامترهای لازم در قالب JSON
- دریافت پاسخ و نمایش آن در صفحه

### ۴. مدیریت خطا (Error Handling)
- نمایش خطاهای ارتباط با سرور
- اعتبارسنجی فرم قبل از ارسال
- نمایش پیام‌های toast برای اطلاع‌رسانی

## نحوه عملکرد

1. کاربر نوع پردازش (Thread یا Process) را انتخاب می‌کند
2. بر اساس انتخاب، لیست ابزارهای همزمانی مربوطه نمایش داده می‌شود
3. کاربر ابزار همزمانی مورد نظر را انتخاب می‌کند
4. لیست سناریوها (1 تا 3) فعال می‌شود
5. کاربر شماره سناریو را انتخاب کرده و دکمه "اجرای سناریو" را کلیک می‌کند
6. درخواست به سرور ارسال شده و پاسخ دریافت می‌شود
7. نتایج به صورت formatted در صفحه نمایش داده می‌شود

## نکات طراحی

- **تم رنگی**: استفاده از رنگ‌های آبی و بنفش که نشان‌دهنده مفاهیم تکنولوژی و پردازش است
- **آیکون‌ها**: استفاده از آیکون‌های Bootstrap برای بهبود تجربه کاربری
- **انیمیشن‌ها**: نمایش انیمیشن لودینگ و اسکرول نرم به بخش نتایج
- **چیدمان**: چیدمان مبتنی on card برای جداسازی منطقی بخش‌های مختلف

## استانداردهای رعایت شده

- **HTML5**: استفاده از semantic HTML
- **CSS3**: استفاده از gradient backgrounds و shadow effects
- **JavaScript ES6**: استفاده از توابع arrow، async/await و const/let
- **Bootstrap 5**: استفاده از کامپوننت‌های responsive
- **RTL Support**: پشتیبانی کامل از راست‌چین برای زبان فارسی

این صفحه وب به خوبی نیازهای پروژه را برآورده می‌کند و به کاربران امکان می‌دهد به راحتی با سیستم تعامل داشته و نتایج پردازش‌های موازی را مشاهده کنند.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# داکرایز کردن پروژه

## مقدمه
در این بخش، پروژه پردازش موازی را با استفاده از Docker containerize کرده‌ام. با استفاده از داکر، امکان اجرای یکسان پروژه در محیط‌های مختلف فراهم شده و وابستگی‌های پروژه به صورت ایزوله مدیریت می‌شوند.

## پیش‌نیازها

### نصب Docker و Docker Compose
```bash
# بروزرسانی سیستم
sudo apt update && sudo apt upgrade -y

# نصب Docker
sudo apt install docker.io -y

# نصب Docker Compose
sudo apt install docker-compose -y

# افزودن کاربر به گروه docker (اختیاری)
sudo usermod -aG docker $USER

# راه‌اندازی سرویس Docker
sudo systemctl enable docker
sudo systemctl start docker
```



## فایل‌های پیکربندی Docker

### 1. Dockerfile
فایل Dockerfile برای ساخت image برنامه:

```dockerfile
FROM python:3.9-slim

WORKDIR /app

# کپی کردن فایل requirements و نصب dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# کپی کردن تمام فایل‌های پروژه
COPY . .

EXPOSE 8000

CMD ["uvicorn", "process_api:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 2. docker-compose.yml
فایل docker-compose.yml اصلاح شده:

```yaml
version: '3.8'

services:
  process-api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    environment:
      - PYTHONPATH=/app
    restart: unless-stopped
    command: uvicorn process_api:app --host 0.0.0.0 --port 8000

  thread-api:
    build: .
    ports:
      - "8001:8001"
    volumes:
      - .:/app
    environment:
      - PYTHONPATH=/app
    restart: unless-stopped
    command: uvicorn thread_api:app --host 0.0.0.0 --port 8001

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
      - .:/usr/share/nginx/html
    depends_on:
      - process-api
      - thread-api
    restart: unless-stopped
```

### 3. nginx.conf
فایل پیکربندی Nginx:

```nginx
server {
    listen 80;
    server_name localhost;
    
    # سرویس دهی فایل‌های استاتیک
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
    
    # redirect برای Process API
    location /process/ {
        proxy_pass http://process-api:8000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # redirect برای Thread API
    location /thread/ {
        proxy_pass http://thread-api:8001/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # API endpoints
    location /api/run-scenario {
        # تشخیص نوع درخواست و redirect به سرویس مناسب
        if ($request_method = POST) {
            # اینجا نیاز به logic پیشرفته‌تر داریم
            # به طور موقت به process-api redirect می‌کنیم
            proxy_pass http://process-api:8000/api/run-scenario;
        }
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

## مراحل اجرا

### 1. ساخت image های داکر
```bash
# ساخت image برای سرویس‌ها
docker-compose build
```

### 2. راه‌اندازی کانتینرها
```bash
# اجرای سرویس‌ها در پس‌زمینه
docker-compose up -d
```

### 3. بررسی وضعیت کانتینرها
```bash
# مشاهده وضعیت کانتینرها
docker-compose ps

# مشاهده لاگ‌های کانتینرها
docker-compose logs
```

### 4. توقف سرویس‌ها
```bash
# توقف کانتینرها
docker-compose down
```

## اصلاحات انجام شده در کدها

### 1. اصلاح script.js
برای تطبیق با محیط داکر، آدرس API در فایل script.js به صورت زیر تغییر کرد:

```javascript
// آدرس API به صورت relative تغییر کرد
const API_BASE_URL = '';

// در تابع ارسال فرم
const apiUrl = '/api/run-scenario';
```

### 2. اضافه کردن CORS به API ها
برای امکان ارتباط frontend با API‌ها، CORS middleware به هر دو API اضافه شد:

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # در production محدودتر کنید
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

## تست پروژه

### 1. تست دسترسی به frontend
باز کردن مرورگر و رفتن به آدرس:
```
http://localhost
```

### 2. تست API ها مستقیماً
```bash
# تست Process API
curl -X GET http://localhost:8000/

# تست Thread API
curl -X GET http://localhost:8001/
```

### 3. تست endpoint اصلی
```bash
# تست ارسال درخواست به API
curl -X POST http://localhost/api/run-scenario \
  -H "Content-Type: application/json" \
  -d '{"section_type": "process", "section_name": "Spawning a process", "scenario_number": 1}'
```

## مشکلات و راه‌حل‌ها

### مشکل 1: تداخل پورت‌ها
**راه‌حل**: استفاده از پورت‌های مختلف برای API ها و proxy کردن از طریق Nginx

### مشکل 2: CORS errors
**راه‌حل**: اضافه کردن CORS middleware به API ها

### مشکل 3: مسیرهای نسبی در frontend
**راه‌حل**: تغییر آدرس API به relative paths

## نتیجه‌گیری
پروژه با موفقیت containerize شد و تمامی سرویس‌ها (Process API, Thread API, Nginx, Frontend) به درستی با هم کار می‌کنند. با استفاده از Docker Compose، مدیریت و اجرای پروژه بسیار ساده شده است.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
